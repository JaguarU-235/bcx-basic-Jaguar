'
' Build a linkfile for RB+ ROM
' 22-Feb-2015 Reboot
' Run it like:
' build link <path+filename of assets file> <base project dir>
'

Mode StrSpace 0

Global Const __argmax = 50
Global __argc As Int
Global __argv() As String
ConvertCMDLine

'If __argc <> 2
'End
'EndIf

Dim basedir$ = __argv(2)

'basedir$ = "..\projects\spiral\"
'__argv(1) = "..\projects\spiral\assets.txt"

If Not Exist(__argv(1))
  Open basedir$ + "\build\romassets.inc" for Output As # 3 : Close # 3
  Open basedir$ + "\build\romassets.h" for Output As # 4 : Close # 4
  Open basedir$ + "\build\ramassets.inc" for Output As # 6 : Close # 6
  Open basedir$ + "\build\linkfile.bin" for Output As # 2 : Close # 2
  End
EndIf

Dim base_adr% = $802000 + 196 'rom base address + header + copy routine size (hardcoded for now)
Dim ass_adr% = base_adr%
Dim tempbuf(4 * 1024 * 1024) As Byte
Dim tempadr As Int = V:tempbuf(0)
Dim fullnameslash$

Dim romabs$, varname$, type$, assetfile$
Open __argv(1) for Input As # 1
Open basedir$ + "\build\linkfile.bin" for Output As # 2
Open basedir$ + "\build\romassets.inc" for Output As # 3
Open basedir$ + "\build\romassets.h" for Output As # 4
Open basedir$ + "\build\ramassets.inc" for Output As # 6
Open basedir$ + "\build\build.log" for Append As # 10
Print # 10; "Buildlink starting"
Print # 6; ".dphrase"
Dim size As Int
Dim fullname$
Dim plainfile$
Dim i As Int

Dim filepointer As Int

Dim pad$ = "PUSH THE BUTTON!"
While Not EOF(# 1)
  Print # 10; "Reading assets.txt line"
  filepointer = Seek(# 1)
  Line Input # 1, romabs$
  romabs$ = Left$(romabs$, 1)
  If romabs$ = ";" Or romabs$ = "#" Or romabs$ = "'" Or romabs$ = "*" Or romabs$ = ""
    'Print "Skipping line"
    GoTo skipline
  EndIf
  Seek # 1, filepointer
  Input # 1, romabs$, varname$, type$, assetfile$
  romabs$ = Trim$(romabs$)
  varname$ = Trim$(varname$)
  type$ = Trim$(type$)
  assetfile$ = Trim$(assetfile$)

  Print # 10; "Processing " + assetfile$

  'Align to 16 bytes, just cause I say so :P
  BPut # 2, V:pad$, (16 - (ass_adr% And $f)) And $f
  ass_adr% = (ass_adr% + 15) And $fffffff0
  fullname$ = basedir$ + "\" + assetfile$
  fullnameslash$ = assetfile$
  plainfile$ = SubStr(assetfile$, RInStr(assetfile$, "\") + 1)

  If Not Exist(fullname$)
    Print # 10; "Aborting - Couldn't find file " + fullname$
    'Message "Aborting - Couldn't find file " + fullname$
    End
  EndIf
  For i = 1 To Len(fullnameslash$)
    If Mid$(fullnameslash$, i, 1) = "\"
      Mid$(fullnameslash$, i, 1) = "/"
    EndIf
  Next i
  If Lower$(type$) = "gfx_clut"
    convertbmp(fullname$, True)
    If Upper$(romabs$) = "ROM"
      Print # 3; varname$; " EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; " 0x"; Hex$(ass_adr%)
      Open basedir$ + "\build\" + plainfile$ + ".gfxdata" for Input As # 5
      size = LOF(# 5)
      BGet # 5, tempadr, size
      BPut # 2, tempadr, size
      Close # 5
      Add ass_adr%, size

      'Align to 16 bytes, just cause I say so :P
      BPut # 2, V:pad$, (16 - (ass_adr% And $f)) And $f
      ass_adr% = (ass_adr% + 15) And $fffffff0

      Print # 3; varname$; "_clut EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; "_clut 0x"; Hex$(ass_adr%)
      Open basedir$ + "\build\" + plainfile$ + ".clut" for Input As # 5
      size = LOF(# 5)
      BGet # 5, tempadr, size
      BPut # 2, tempadr, size
      Close # 5
      Add ass_adr%, size
    Else
      Print # 6; varname$; ": incbin ""build/" + plainfile$ + ".gfxdata" + """"
      Print # 6; varname$; "_end:"
      Print # 6; varname$; "_clut: incbin ""build/" + plainfile$ + ".clut" + """"
      Print # 6; varname$; "_clut_end:"
      Print # 6; ".extern " + varname$
      Print # 6; ".extern " + varname$ + "_clut"
      Print # 6; ".dphrase"
      Print # 4; "extern void *" + varname$ + " asm(""" + varname$ + """);"
      Print # 4; "extern void *" + varname$ + "_clut" + " asm(""" + varname$ + "_clut"");"
    EndIf
  ElseIf Lower$(type$) = "gfx_noclut"
    convertbmp(fullname$, False)
    If Upper$(romabs$) = "ROM"
      Print # 3; varname$; " EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; " 0x"; Hex$(ass_adr%)
      'Print basedir$ + "\build\" + plainfile$ + ".gfxdata"
      Open basedir$ + "\build\" + plainfile$ + ".gfxdata" for Input As # 5
      size = LOF(# 5)
      BGet # 5, tempadr, size
      BPut # 2, tempadr, size
      Close # 5
      Add ass_adr%, size
      Print # 3; varname$; "_end EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; "_end 0x"; Hex$(ass_adr%)
    Else
      Print # 6; varname$; ": incbin ""build/" + plainfile$ + ".gfxdata" + """"
      Print # 6; varname$; "_end:"
      Print # 6; ".extern " + varname$
      Print # 6; ".dphrase"
      Print # 4; "extern void *" + varname$ + " asm(""" + varname$ + """);"
    EndIf
  ElseIf Left$(Lower$(type$), 7) = "sfx_raw"
    Local pHdl As Handle, pID As Int
    Local l As Large, e%, h%
    l =   System("sox " + fullname$ + "--channels 1 --bits 8 --encoding signed-integer """ + fullname$ + ".raw"" --show-progress rate -v " + SubStr(type$, 8))
    If !l Then Message "Can't run sox - aborting!" : End

    'Wait till sox finishes
    pHdl = LoLarge(l) ' process handle
    pID = HiLarge(l)  ' process ID

    ~GetExitCodeProcess(pHdl, V:e)
    While e = STATUS_PENDING
      ~MsgWaitForMultipleObjects(1, V:pHdl, _
        0, 1000, QS_ALLINPUT)
      '    Beep -1
      DoEvents
      ~GetExitCodeProcess(pHdl, V:e)
    Wend
    ~CloseHandle(pHdl)

  ElseIf Lower$(type$) = "sfx_adpcm"
  Else
    If Upper$(romabs$) = "ROM"
      Print # 3; varname$; " EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; " 0x"; Hex$(ass_adr%)
      Open fullname$ for Input As # 5
      size = LOF(# 5)
      BGet # 5, tempadr, size
      BPut # 2, tempadr, size
      Close # 5
      Add ass_adr%, size
      Print # 3; varname$; "_end EQU $"; Hex$(ass_adr%)
      Print # 4; "#define "; varname$; "_end 0x"; Hex$(ass_adr%)
    Else
      Print # 6; varname$; ": incbin """ + fullnameslash$ + """"
      Print # 6; varname$; "_end:"
      Print # 6; ".extern " + varname$
      Print # 6; ".dphrase"
      Print # 4; "extern void *" + varname$ + " asm(""" + varname$ + """);"
    EndIf
  EndIf
  skipline:
Wend
Close # 1
Close # 3
Close # 4
Close # 6
Print # 10; "Buildlink finished - everything went fine!"

'Repeat
'##E#
'Until InKey$ <> ""

End


'
' Convert a 8bpp bmp to jag format
' Code by promethea, with original 68k code by Sinister developments
'
' Foooooked in the arse by ggn in 27-02-2013 (WARNING - only 256c works proppa for now!)
' Mono mode added by ggn in 15-02-2015 for Kevvykevkevkevkev
' 4bit converter fixed in 22-02-2015
'
' Needs to be launched with parameters from the command prompt:
' convbmp <input filename> <output filename> <colour bit depth> <width in bytes> <height in scanlines>
' It will output <filename>.jag
'
Procedure convertbmp(file$, dumpclut As Bool)
  Dim infile$, outfile$
  Dim depth, width, height, l, i, x As Int
  Dim sourceaddr, xBGR As Int

  '
  ' Process command line params
  '
  infile$ = file$
  outfile$ = basedir$ + "\build\" + plainfile$


  'TODO: check if destination files exist and are of newer date than source file

  '
  ' Read in source file
  '
  'Print "open "; file$
  'Repeat
  'Until InKey$ <> ""
  Open file$ for Binary As # 5
  l = LOF(# 5)
  Dim sourcebmp(l) As Byte
  sourceaddr = V:sourcebmp(0)
  Dim aaa As Byte
  For i = 1 To l
    BGet # 5, V:aaa, 1
    sourcebmp(i - 1) = aaa
  Next i
  Close # 5
  '
  ' Figure out width and height
  '
  width = sourcebmp($15) * $100000 + sourcebmp($14) * $1000 + sourcebmp($13) * $100 + sourcebmp($12)
  height = sourcebmp($19) * $100000 + sourcebmp($18) * $1000 + sourcebmp($17) * $100 + sourcebmp($16)
  depth = sourcebmp($1d) * $100 + sourcebmp($1c)

  '
  ' Convert palette to jag format
  '
  If sourcebmp($1c) <> 4
    xBGR = 53
  Else
    xBGR = $35
  EndIf
  Dim palette(255) As Word
  Dim red, green, blue As Word
  For i = 0 To (2 ^ depth) - 1
    blue = Rol&((Shr&(sourcebmp(xBGR + 1), 3)), 6)
    green = Shr&(sourcebmp(xBGR + 2), 2)
    red = Ror&(Shr&(sourcebmp(xBGR + 3), 3), 5)
    palette(i) = Ror&(red Or green Or blue, 8)            'Fuck you endianess!
    Add xBGR, 4
  Next i

  'Print depth
  'Repeat
  'Until InKey$ <> ""

  '
  ' Do the conversion
  '
  Dim screenstart, destindex As Int
  Dim col As Byte
  Select depth
  Case -1                         '***************** just dump the palette & exit
    Open file$ for Binary As # 5
    For i = 1 To 256
      BPut # 1, V:palette(i - 1), 2
    Next i
    Close # 5

  Case 1                          '***************** 1-bit
    Global hBmp As Long
    Dim y As Int ', x As Int
    Dim b$
    hBmp = LoadImage(0, file$, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE)
    Dim z As Picture
    Set z = LoadPicture(file$)
    Dim w As Int = Round(z.Width / 26.46)
    Dim h As Int = Round(z.Height / 26.46)
    Dim yy As Int = h


    If dumpclut
      Open outfile$ + ".clut" for Output As # 5 'clut for 1bpp? lol
      Close # 5
    EndIf

    If checkdate(file$, outfile$ + ".gfxdata")

      Open outfile$ + ".gfxdata" for Output As # 5

      OpenW 1, 0, 0, 500, 300, 0
      While yy > 0
        Put 0, yy - h, hBmp
        Get 0, 0, (w - 1), Min(199, yy - 1), b$
        Dim picadr% = V:b$ + 24

        '
        ' Dump mono bitmap
        '
        Dim outb As Byte, pixel As Byte
        Dim outadr% = V:outb
        Local align = (w / 8) And 7

        For y = 0 To Min(199, yy - 1)
          pixel = 128
          outb = 0
          For x = 0 To w - 1
            If LPeek(picadr%) <> 0
              outb = outb | pixel
            EndIf
            pixel = pixel >> 1
            If pixel = 0
              BPut # 5, outadr%, 1
              outb = 0
              pixel = 128
            EndIf
            Add picadr%, 4
          Next x
          If  align > 0
            outb = 0
            For i = 0 To 7 - align
              BPut # 5, V:outadr%, 1
            Next i
          EndIf
        Next y
        yy = yy - 200
      Wend
      CloseW 1
      Close # 5
    EndIf
  Case 4                          '***************** 4-bit
    width = width / 2
    screenstart = 54 + 64
    Dim outbuffer(width * height) As Byte
    destindex = width * (height - 1)
    For i = 1 To height
      For x = 0 To width - 1
        outbuffer(destindex + x) = sourcebmp(screenstart)
        Inc screenstart
      Next x
      Sub destindex, width
    Next i
    If checkdate(file$, outfile$ + ".gfxdata")
      Open outfile$ + ".gfxdata" for Binary As # 5
      For i = 1 To width * height
        BPut # 5, V:outbuffer(i - 1), 1
      Next i
      Close # 5
    EndIf
    If dumpclut
      If checkdate(file$, outfile$ + ".clut")
        Open outfile$ + ".clut" for Binary As # 5
        For i = 1 To 16
          BPut # 5, V:palette(i - 1), 2
        Next i
        Close # 5
      EndIf
    EndIf
  Case 8                          '***************** 8-bit
    screenstart = 1024 + 54
    Dim outbuffer(width * height) As Byte
    destindex = width * (height - 1)
    For i = 1 To height
      For x = 0 To width - 1
        outbuffer(destindex + x) = sourcebmp(screenstart)
        Inc screenstart
      Next x
      Sub destindex, width
    Next i
    If dumpclut
      If checkdate(file$, outfile$ + ".clut")
        BSave outfile$ + ".clut", V:palette(0), 512
      EndIf
    EndIf
    If checkdate(file$, outfile$ + ".gfxdata")
      Open outfile$ + ".gfxdata" for Binary As # 5
      For i = 1 To width * height
        BPut # 5, V:outbuffer(i - 1), 1
      Next i
      Close # 5
    EndIf
  Case 16                          '***************** 16-bit raw - NOT WORKING
    screenstart = 1024 + 54
    Dim outbuffer16(width * height * 2) As Word
    destindex = width * (height - 1)
    For i = 1 To height
      For x = 0 To width - 1
        col = sourcebmp(screenstart)
        outbuffer16(destindex + x) = palette(col)
        Inc screenstart
      Next x
      Sub destindex, width
    Next i
    Open Left$(infile$, Len(infile$), 4) + ".jag" for Binary As # 1
    For i = 1 To width * height
      BPut # 1, V:outbuffer16(i - 1), 2
    Next i
  EndSelect
Return

>Function checkdate(a$, b$)
  If Not Exist(b$)
    Return True
  EndIf
  Return FileDateTime(a$) > FileDateTime(b$)
EndFunc
Procedure ConvertCMDLine()
  // The global variable __argc holds the
  // number of commandline arguments after executing ConvertCMDLine().
  // Arguments are separated by space(s)

  // __argv() is an Array with the splitted arguments.
  // Only __argmax arguments are returned.

  // __argv(0) holds the complete path, filename included.

  Local i As Int = 0, j As Int = 0
  Local cmd$

  Local LargeArg As Boolean = False
  Local a$

  ReDim __argv(__argmax)
  __argv(0) = App.FileName

  // Remove quotes
  If Left$(__argv(0), 1) = #34
    __argv(0) = Mid(__argv(0), 2)
  EndIf
  If Right$(__argv(0), 1) = #34
    __argv(0) = Left(__argv(0), Len(__argv(0)) - 1)
  EndIf

  cmd$ = Trim(_DosCmd$) + #32
  If Left$(cmd$, 1) <> """"
    i = InStr(cmd$, #32)
  Else
    'Debug.Print InStr(cmd$, """", 2)
    i = InStr(cmd$, #34, 2) : LargeArg = True

    cmd$ = Mid$(cmd$, 2) // remove space at start
  EndIf

  While i > 0
    j++
    If LargeArg
      // remove space at end
      a$ = Left$(cmd$, i - 2)
      If Len(a)
        __argv(j) = Left$(cmd$, i - 2)
      Else
        j--
      EndIf
      LargeArg = False
    Else
      // only remove space at end
      a$ = Left$(cmd$, i - 1)
      If Len(a)
        __argv(j) = Left$(cmd$, i - 1)
      Else
        j--
      EndIf
    EndIf

    Exit If (i + 1) > Len(cmd$)

    cmd$ = Mid$(cmd$, i + 1)

    If Left$(cmd$, 1) <> """"
      i = InStr(cmd$, #32)
    Else
      i = InStr(cmd$, #34, 2) : LargeArg = True
      cmd$ = Mid$(cmd$, 2) // remove space at beginning
    EndIf
  Wend

  // Return number of arguments
  __argc = j

EndProcedure
$DatFile
$FormVersion = 2
$ExeName = ..\BIN\Buildlink.exe
$FileDescription = Description
$Comments = Author: Not registered   
$CompanyName = Not registered   
$LegalCopyright = © 2015 Not registered   
$LanguageId = 0409
$FileVersion = %d.%d.%d.%d
$ProductVersion = %d.%d.%d.%d
$DatFile
